#version 330 core


uniform sampler2D baseTex0;

in vec2 uv;
out vec4 colour;


// Create a screen door transparency effect.
void ditherFragment(in vec4 fragColour){
	// 4x4 Bayer ordered dithering matrix.
	// Each element represents an alpha threshold.
	const mat4 ditherMatrix = mat4(
		vec4(1.f/17.f,  9.f/17.f,  3.f/17.f,  11.f/17.f),
		vec4(13.f/17.f, 5.f/17.f,  15.f/17.f, 7.f/17.f),
		vec4(4.f/17.f,  12.f/17.f, 2.f/17.f,  10.f/17.f),
		vec4(16.f/17.f, 8.f/17.f,  14.f/17.f, 6.f/17.f)
	);
	vec4 ditherRow;
	float ditherThreshold;
	
	// Notes:
	// 
	// OpenGL doesn't like it when we access arrays using
	// a variable index in the fragment shader, so we need
	// to determine which value to use by conditionals.
	//
	// Rather than calculating the index and having a single
	// switch statement, we use one statement for each index.
	// Because switch statements aren't optimised into jump
	// tables in shader code, this results in less comparisons
	// on average.
	
	// Determine which row of the dither matrix to use.
	switch(int(gl_FragCoord.x) % 4){
		case 0:
			ditherRow = ditherMatrix[0];
		break;
		case 1:
			ditherRow = ditherMatrix[1];
		break;
		case 2:
			ditherRow = ditherMatrix[2];
		break;
		default:
			ditherRow = ditherMatrix[3];
	}
	// Now find the column and get the threshold value.
	switch(int(gl_FragCoord.y) % 4){
		case 0:
			ditherThreshold = ditherRow[0];
		break;
		case 1:
			ditherThreshold = ditherRow[1];
		break;
		case 2:
			ditherThreshold = ditherRow[2];
		break;
		default:
			ditherThreshold = ditherRow[3];
	}
	
	// If the fragment is below the alpha threshold, discard it.
	if(fragColour.a < ditherThreshold){
		discard;
	}
	
	/*
	// This causes the program to crash during shader compilation on some hardware!
	if(fragColour.a < ditherMatrix[int(gl_FragCoord.x) % 4][int(gl_FragCoord.y) % 4]){
		discard;
	}
	*/
}


void main(){
	vec4 fragColour = texture(baseTex0, uv);
	
	// If this fragment is fully transparent,
	// discard it to avoid writing to the z-buffer.
	if(fragColour.a == 0.f){
		discard;
	}
	// If the fragment isn't full opaque,
	// use screen door transparency.
	if(fragColour.a < 1.f){
		ditherFragment(fragColour);
	}
	
	/*
	// Note that we try to use as few nested conditionals
	// as possible to prevent desynchronization of wavefronts,
	// so it's probably not a good idea to do this.
	//
	// We might have to go through all 16 conditionals every time
	// like they do in here:
	// https://www.reddit.com/r/godot/comments/bxfyws/heres_a_dithered_opacity_aka_hashed_transparency/
	if(fragColour.a != 1.f){
		// If this fragment is fully transparent,
		// discard it to avoid writing to the z-buffer.
		if(fragColour.a == 0.f){
			discard;
		
		// If the fragment is neither fully transparent nor
		// full opaque, we should use screen door transparency.
		}else{
			ditherFragment(fragColour);
		}
	}
	*/	
	
	colour = vec4(fragColour.rgb, 1.f);
}